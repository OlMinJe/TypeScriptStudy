/* 
< 배열 >
- 타입을 정의할 때 "요소의_타입[]" 형식으로 작성한다.
- 제네릭 문법: "Array<요소의타입>"의 형식으로 작성한다.
*/
let numArr: number[] = [1, 2, 3];
let strArr: string[] = ['hello', 'im', 'minje'];
let boolArr: Array<boolean> = [true, false, true];

/* 
< 배열에 들어가는 요소들의 타입이 다양할 경우 >
변수에 마우스 커서를 올려보면, 타입스크립트가 점진적 타입 시스템을 사용하기 때문에
변수의 타입을 초기화 하는 기준을 토대로 자동으로 추론한다.
*/
let miltiArr: (number | string)[] = [1, 'hello'];

// 다차원 배열의 타입을 정의하는 방법
let doubleArr: number[][] = [
  [1, 2, 3],
  [4, 5],
];

/*  --------------------------------------------------------------------
< 튜플 >
- 길이와 타입이 고정된 배열을 의미한다.
- 타입의 순서와 길이가 다르다면, 오류가 난다.
- "[요소의_타입, 요소의_타입]"의 형식은 길이가 2인 number 타입의 요소만 담는 배열이다.
*/
let tup1: [number, number] = [1, 2];
let tup2: [number, string, boolean] = [1, 'string', true];

/*
컴파일 후 스크립트 코드를 확인해보면, 튜플도 배열로 컴파일 되는 걸 확인할 수 있다.
참고로 컴파일 이후에는 배열이기 때문에, 튜플에 요소를 추가해도 오류가 발생하지 않는다.

*/
tup1.push(1);

/* 
Q. 그렇다면 튜플은 언제 유용하게 사용할 수 있을까?
A. 인덱스의 순서대로 타입이 동일해야 하는 경우 사용할 수 있으며, 값을 잘못 넣는 걸 방지해준다.
   다차원 배열인 경우 "[요소의_타입, 요소의_타입][]"의 형식으로 작성해준다.
*/
const users: [string, number][] = [
  ['이민제', 1],
  ['이만제', 2],
  ['이민재', 3],
  // [6, '김홀길'], // 오류 코드
];
